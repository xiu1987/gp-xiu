<!DOCTYPE html>
<html>
  <head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta http-equiv="X-UA-Compatible" content="chrome=1,IE=edge" />
	<title>GpXiutTme</title>
	<style>
		html {
			height:100%;
		}
		body {
			background-color:#2C3547;
			margin:0;
			height:100%;
		}
	</style>
	<!-- copy these lines to your document head: -->

	<meta name="viewport" content="user-scalable=yes, width=1240" />
	<style>
.heading-primary {
    font-family: "Arial Black", Gadget, sans-serif;
    font-size: 3em;
    color: #2c3e50;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    text-align: center;
}

.body-text {
    font-family: "Georgia", serif;
    font-size: 1.2em;
    line-height: 1.8;
    color: #34495e;
}

.special-text {
    background: linear-gradient(45deg, #ff3366, #ff9933);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    font-weight: bold;
}
</style>
<script>
// 圆形边界碰撞
function initParticles() {
    const canvas = document.createElement('canvas');
    canvas.id = 'particles-with-materials';
    canvas.style.cssText = `
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        z-index: 4 !important;
        background: transparent !important;
        pointer-events: none !important;
    `;
    
    const sceneContainer = document.querySelector('.HYPE_scene');
    if (sceneContainer) {
        sceneContainer.appendChild(canvas);
    } else {
        document.body.appendChild(canvas);
    }
    const ctx = canvas.getContext('2d');
    
    // 尺寸调整
    function resizeCanvas() {
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // 获取素材并设置层级
    const repulseMaterial = document.getElementById('materialRepulse');
    const grabMaterial = document.getElementById('materialGrab');
    
    if (repulseMaterial) {
        repulseMaterial.style.position = 'absolute';
        repulseMaterial.style.zIndex = '10';
    }
    if (grabMaterial) {
        grabMaterial.style.position = 'absolute';
        grabMaterial.style.zIndex = '10';
    }
    
    // 核心配置 - 新增圆形边界参数
    const config = {
        particles: {
            number: { value: 150 },
            color: { 
                value: [
                    "#4fb2ff",  // 深蓝色
                    "#6C5B7B",  // 紫色
                    "#2aec81",  // 绿色
                    "#F67280",  // 浅红色
                    "#baa414"   // 浅橙色
                ] 
            },
            size: { value: 3, random: true, random_min: 0.5 },
            lineLinked: { enable: true, distance: 250 },
            move: { 
                enable: true, 
                speed: 0.1,
                // 边界模式："circle" 圆形边界，"rectangle" 矩形边界
                boundary_mode: "circle",
                // 圆形边界半径比例（0.9表示为画布最小边的90%）
                circle_radius_ratio: 0.9
            }
        },
        interactivity: {
            modes: {
                repulse: {
                    distance: 250,
                    strength: 0.01,
                    duration: 0.3
                }
            }
        },
        materialLink: {
            maxDistance: 100,
            baseOpacity: 0.2
        }
    };
    
    // 创建粒子
    const particles = [];
    for (let i = 0; i < config.particles.number.value; i++) {
        let size = config.particles.size.random 
            ? config.particles.size.random_min + Math.random() * (config.particles.size.value - config.particles.size.random_min)
            : config.particles.size.value;
            
        let color = Array.isArray(config.particles.color.value)
            ? config.particles.color.value[Math.floor(Math.random() * config.particles.color.value.length)]
            : config.particles.color.value;

        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: size,
            color: color,
            opacity: 0.5 + Math.random() * 0.5,
            vx: (Math.random() - 0.5) * config.particles.move.speed * 2,
            vy: (Math.random() - 0.5) * config.particles.move.speed * 2
        });
    }
    
    // 素材位置计算
    function getMaterialPosition(material) {
        if (!material) return null;
        const canvasRect = canvas.getBoundingClientRect();
        const matRect = material.getBoundingClientRect();
        return {
            x: matRect.left - canvasRect.left + matRect.width/2,
            y: matRect.top - canvasRect.top + matRect.height/2
        };
    }
    
    // 【核心修改】圆形边界碰撞检测与处理
    function handleCircularBoundary(particle) {
        // 计算圆形边界参数
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(canvas.width, canvas.height) / 1.3 * config.particles.move.circle_radius_ratio;
        
        // 计算粒子到圆心的距离
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // 如果粒子超出圆形边界
        if (distance + particle.size > radius) {
            // 计算边界上的碰撞点
            const collisionX = centerX + (dx / distance) * radius;
            const collisionY = centerY + (dy / distance) * radius;
            
            // 计算法向量（从圆心指向粒子）
            const nx = dx / distance;
            const ny = dy / distance;
            
            // 计算入射向量与法向量的点积
            const dotProduct = particle.vx * nx + particle.vy * ny;
            
            // 计算反射向量（实现弹性碰撞）
            particle.vx = particle.vx - 2 * dotProduct * nx;
            particle.vy = particle.vy - 2 * dotProduct * ny;
            
            // 将粒子位置调整到边界内
            particle.x = collisionX - nx * particle.size;
            particle.y = collisionY - ny * particle.size;
        }
    }
    
    // 矩形边界处理（保留作为可选模式）
    function handleRectangularBoundary(particle) {
        if (particle.x < particle.size) {
            particle.x = particle.size;
            particle.vx = -particle.vx;
        } else if (particle.x > canvas.width - particle.size) {
            particle.x = canvas.width - particle.size;
            particle.vx = -particle.vx;
        }
        
        if (particle.y < particle.size) {
            particle.y = particle.size;
            particle.vy = -particle.vy;
        } else if (particle.y > canvas.height - particle.size) {
            particle.y = canvas.height - particle.size;
            particle.vy = -particle.vy;
        }
    }
    
    // 动画循环
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 排斥效果
        const repulsePos = getMaterialPosition(repulseMaterial);
        if (repulsePos) {
            particles.forEach(p => {
                const dx = p.x - repulsePos.x;
                const dy = p.y - repulsePos.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < config.interactivity.modes.repulse.distance && distance > 0) {
                    const force = (1 - distance/config.interactivity.modes.repulse.distance) * 
                                  config.interactivity.modes.repulse.strength;
                    p.vx += (dx/distance) * force;
                    p.vy += (dy/distance) * force;
                }
            });
        }
        
        // 抓取连线
        const grabPos = getMaterialPosition(grabMaterial);
        if (grabPos) {
            particles.forEach(p => {
                const distance = Math.sqrt(Math.pow(p.x - grabPos.x, 2) + Math.pow(p.y - grabPos.y, 2));
                if (distance < config.materialLink.maxDistance) {
                    const opacity = config.materialLink.baseOpacity * (1 - distance / config.materialLink.maxDistance);
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                    ctx.lineWidth = 1;
                    ctx.moveTo(grabPos.x, grabPos.y);
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
            });
        }
        
        // 粒子间连线
        if (config.particles.lineLinked.enable) {
            particles.forEach((p1, i) => {
                particles.forEach((p2, j) => {
                    if (i < j) {
                        const distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                        if (distance < config.particles.lineLinked.distance) {
                            const opacity = 0.2 * (1 - distance / 150);
                            ctx.beginPath();
                            ctx.strokeStyle = `rgba(255,255,255,${opacity})`;
                            ctx.lineWidth = 1;
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                });
            });
        }
        
        // 更新粒子
        particles.forEach(p => {
            // 根据配置选择边界模式
            if (config.particles.move.boundary_mode === "circle") {
                handleCircularBoundary(p);
            } else {
                handleRectangularBoundary(p);
            }
            
            p.x += p.vx;
            p.y += p.vy;
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fillStyle = p.color;
            ctx.fill();
        });
        
        requestAnimationFrame(animate);
    }
    
    animate();
}

// Hype初始化
if (!window.HYPE_eventListeners) window.HYPE_eventListeners = [];
window.HYPE_eventListeners.push({
    "type": "HypeDocumentLoad",
    "callback": function() {
        setTimeout(initParticles, 300);
    }
});
</script>

	<!-- end copy -->
  </head>
  <body>
	<!-- copy these lines to your document: -->

	<div id="gpxiuttme_hype_container" class="HYPE_document" style="margin:auto;position:relative;width:100%;height:100%;overflow:hidden;">
		<script type="text/javascript" charset="utf-8" src="GpXiutTme.hyperesources/gpxiuttme_hype_generated_script.js?50749"></script>
	</div>

	<!-- end copy -->
	


	<!-- text content for search engines: -->

	<div style="display:none" aria-hidden=true>

		<div>60
</div>
		<div>02
</div>
		<div>53
</div>
		<div>38
</div>
		<div>03
</div>
		<div>01</div>
		<div>54
</div>
		<div>04
</div>
		<div>39
</div>
		<div>
三
</div>
		<div>三十五
</div>
		<div>05
</div>
		<div>二十五
</div>
		<div>08
</div>
		<div>十五
</div>
		<div>55
</div>
		<div>40
</div>
		<div>06
</div>
		<div>09
</div>
		<div>12
</div>
		<div>
四
</div>
		<div>10
</div>
		<div>13
</div>
		<div>41
</div>
		<div>十六
</div>
		<div>五十八
</div>
		<div>11
</div>
		<div>14
</div>
		<div>四十八
</div>
		<div>二十六
</div>
		<div>17
</div>
		<div>15
</div>
		<div>18
</div>
		<div>三十七
</div>
		<div>56
</div>
		<div>16
</div>
		<div>十七
</div>
		<div>19
</div>
		<div>四十九
</div>
		<div>五十九
</div>
		<div>22
</div>
		<div>20
</div>
		<div>二十七
</div>
		<div>23
</div>
		<div>21
</div>
		<div>24
</div>
		<div>07
</div>
		<div>三十六
</div>
		<div>27
</div>
		<div>五十
</div>
		<div>25
</div>
		<div>
二
</div>
		<div>28
</div>
		<div>26
</div>
		<div>29
</div>
		<div>30
</div>
		<div>31
</div>
		<div>
八
</div>
		<div>47
</div>
		<div>32
</div>
		<div>48
</div>
		<div>33
</div>
		<div>
九
</div>
		<div>四十一
</div>
		<div>三十一
</div>
		<div>二十一
</div>
		<div>十一
</div>
		<div>49
</div>
		<div>34
</div>
		<div>
十
</div>
		<div>
零
</div>
		<div>四十二
</div>
		<div>50
</div>
		<div>三十二
</div>
		<div>35
</div>
		<div>二十二
</div>
		<div>十二
</div>
		<div>51
</div>
		<div>36
</div>
		<div>四十三
</div>
		<div>三十三
</div>
		<div>二十三
</div>
		<div>十三
</div>
		<div>五十五
</div>
		<div>四十五
</div>
		<div>四十四
</div>
		<div>三十四
</div>
		<div>二十四
</div>
		<div>十四
</div>
		<div>五十六
</div>
		<div>四十六
</div>
		<div>五十七
</div>
		<div>四十七
</div>
		<div>57
</div>
		<div>42
</div>
		<div>
五
</div>
		<div>58
</div>
		<div>43
</div>
		<div>
六
</div>
		<div>59
</div>
		<div>三十八
</div>
		<div>44
</div>
		<div>二十八
</div>
		<div>十八
</div>
		<div>45
</div>
		<div>
七
</div>
		<div>三十九
</div>
		<div>二十九
</div>
		<div>十九
</div>
		<div>五十一
</div>
		<div>46
</div>
		<div>四十
</div>
		<div>三十
</div>
		<div>二十
</div>
		<div>五十二
</div>
		<div>五十三
</div>
		<div>五十四
</div>
		<div>
一
</div>
		<div>52
</div>
		<div>37
</div>

	</div>

	<!-- end text content: -->

  </body>
</html>
